---
title: "[백준 1074] Z - Python"
date: 2026-01-19
tags: ["알고리즘", "분할정복", "재귀", "백준", "Python"]
---

## 📝 문제

[백준 1074번 - Z](https://www.acmicpc.net/problem/1074)

크기가 2^N × 2^N인 2차원 배열을 Z 모양으로 탐색하려고 합니다. N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 문제입니다.

## 💡 접근 방법

전형적인 분할 정복 문제입니다. 핵심은 **모든 칸을 실제로 방문하지 않고, 목표 좌표가 어느 사분면에 있는지 판단하여 건너뛸 수 있는 부분을 건너뛰는 것**입니다.

1. **4등분 분할**: 현재 영역을 4개의 사분면으로 나눕니다
2. **사분면 판별**: 목표 좌표(r, c)가 어느 사분면에 속하는지 확인합니다
3. **건너뛰기**: 목표가 속하지 않은 사분면은 방문하지 않고 그 영역의 칸 수만큼 카운트에 더합니다
4. **좌표 보정**: 다음 단계로 진입할 때 좌표를 상대 좌표로 변환합니다
5. **반복**: N이 0이 될 때까지 반복합니다

Z 모양 탐색 순서:
- 1사분면 (왼쪽 위) → 2사분면 (오른쪽 위) → 3사분면 (왼쪽 아래) → 4사분면 (오른쪽 아래)

## ✅ 코드

```python
import sys

# 1. 입력 받기
n, r, c = map(int, sys.stdin.readline().split())

ans = 0

# 2. n이 0이 될 때까지 사각형을 쪼개며 좌표 추적
while n > 0:
    # 한 변의 길이의 절반 (n=3이면 2^2 = 4)
    half = 2 ** (n - 1)
    # 한 조각(사분면)의 넓이
    area = half * half
    
    # [1사분면] 왼쪽 위
    if r < half and c < half:
        # 아무것도 더하지 않고 다음 단계로 진입
        pass
        
    # [2사분면] 오른쪽 위
    elif r < half and c >= half:
        ans += area # 1사분면 넓이만큼 건너뛰기
        c -= half   # 좌표를 1사분면 위치로 보정
        
    # [3사분면] 왼쪽 아래
    elif r >= half and c < half:
        ans += area * 2 # 1, 2사분면 넓이만큼 건너뛰기
        r -= half       # 좌표를 1사분면 위치로 보정
        
    # [4사분면] 오른쪽 아래
    else:
        ans += area * 3 # 1, 2, 3사분면 넓이만큼 건너뛰기
        r -= half       # 좌표 보정
        c -= half       # 좌표 보정
        
    # 사각형 크기를 줄여서 다시 반복
    n -= 1

print(ans)
```

## 🔍 핵심 포인트

1. **완전 탐색 X**: 2^N × 2^N 크기를 모두 순회하면 시간 초과 발생 (N이 최대 15일 때 2^30 = 약 10억)
2. **분할 정복 최적화**: 목표 좌표가 있는 사분면만 탐색하고 나머지는 건너뛰기
3. **사분면별 오프셋**:
   - 1사분면: +0
   - 2사분면: +area
   - 3사분면: +area×2
   - 4사분면: +area×3
4. **좌표 보정**: 다음 단계로 진입할 때 좌표를 상대 좌표로 변환해야 함

## 📊 시간 복잡도

- **시간복잡도**: O(N)
  - N번만큼 사분면을 분할하며 각 단계마다 O(1) 연산만 수행
  - N이 최대 15이므로 충분히 빠름
- **공간복잡도**: O(1)
  - 재귀를 사용하지 않고 반복문으로 구현하여 스택 오버플로우 없음

## 🔧 트러블 슈팅 & 어려웠던 점

### 1. 완전 탐색의 함정

처음에는 실제로 2^N × 2^N 배열을 모두 방문하며 카운트하려고 했습니다. 하지만 N이 15일 때 2^30(약 10억) 칸을 방문해야 하므로 시간 초과가 발생했습니다.

**해결**: 분할 정복으로 접근하여, 목표 좌표가 있는 사분면만 탐색하도록 최적화했습니다. 이렇게 하면 O(4^N)에서 O(N)으로 시간 복잡도가 극적으로 개선됩니다.

### 2. 사분면 판별 조건

r과 c를 half와 비교하여 어느 사분면에 속하는지 판단하는데, 처음에는 조건문 순서를 잘못 작성하여 엉뚱한 사분면을 선택했습니다.

**해결**: 
- `r < half and c < half` → 1사분면
- `r < half and c >= half` → 2사분면  
- `r >= half and c < half` → 3사분면
- `r >= half and c >= half` → 4사분면

명확하게 4가지 경우를 구분하여 처리했습니다.

### 3. 좌표 보정의 중요성

다음 단계로 진입할 때 좌표를 보정하지 않으면, 다음 반복에서 잘못된 사분면을 선택하게 됩니다. 예를 들어 c가 6이고 half가 4일 때, 2사분면을 선택했다면 다음 단계에서는 c=2로 보정해야 합니다.

**해결**: 각 사분면에서 적절히 `r -= half` 또는 `c -= half`를 수행하여 좌표를 상대 좌표로 변환했습니다.

### 4. 재귀 vs 반복문

재귀로 구현할 수도 있지만, Python은 재귀 깊이 제한이 있고 반복문이 더 효율적입니다.

**해결**: `while n > 0` 반복문을 사용하여 재귀 호출 없이 구현했습니다. 이렇게 하면 스택 오버플로우 걱정 없이 안전하게 동작합니다.

## 🤔 후기

분할 정복의 핵심을 잘 보여주는 문제였습니다. 단순히 모든 경우를 탐색하는 것이 아니라, 문제의 특성을 이해하고 불필요한 부분을 건너뛰는 최적화가 중요하다는 것을 배웠습니다. 

특히 **"목표 지점이 어디에 있는지만 알면, 나머지는 계산으로 구할 수 있다"**는 통찰이 핵심이었습니다. 이러한 사고방식은 다른 분할 정복 문제에도 적용할 수 있을 것 같습니다.
