---
title: "[백준 7569] 토마토 - Python"
date: 2026-01-18
tags: ["알고리즘", "BFS", "그래프", "백준", "Python"]
---

## 📝 문제

[백준 7569번 - 토마토](https://www.acmicpc.net/problem/7569)

3차원 토마토 상자에서 익은 토마토들이 인접한 익지 않은 토마토들을 익게 만든다. 모든 토마토가 익는데 걸리는 최소 일수를 구하는 문제.

## 💡 접근 방법

2차원 BFS를 3차원으로 확장하면 되는 문제입니다. 기본적인 BFS 로직은 동일하고, 방향만 4방향에서 6방향으로 늘어난다는 점이 핵심입니다.

1. **다중 시작점 BFS**: 처음부터 익어있는 모든 토마토를 큐에 넣고 동시에 BFS를 시작합니다
2. **3차원 탐색**: 6방향(위, 아래, 앞, 뒤, 좌, 우)으로 탐색합니다
3. **날짜 카운팅**: 이전 토마토의 값 + 1을 현재 토마토에 저장하여 날짜를 추적합니다
4. **결과 판정**: 
   - 익지 않은 토마토(0)가 남아있으면 -1을 출력합니다
   - 모두 익었다면 최대 날짜 - 1을 출력합니다 (시작이 1이므로)

## ✅ 코드

```python
import sys
from collections import deque

# 1. 입력 받기
m, n, h = map(int, sys.stdin.readline().split())

# 2. 3차원 그래프 입력 및 시작점(익은 토마토) 찾기
graph = []
queue = deque()

for i in range(h):
    layer = []
    for j in range(n):
        row = list(map(int, sys.stdin.readline().split()))
        for k in range(m):
            if row[k] == 1:
                # 익은 토마토 위치를 큐에 담기 (높이, 세로, 가로)
                queue.append((i, j, k))
        layer.append(row)
    graph.append(layer)

# 3. 6방향 탐색 설정 (위, 아래, 앞, 뒤, 좌, 우)
dh = [1, -1, 0, 0, 0, 0]
dn = [0, 0, 1, -1, 0, 0]
dm = [0, 0, 0, 0, 1, -1]

# 4. BFS 수행
while queue:
    curr_h, curr_n, curr_m = queue.popleft()
    
    for i in range(6):
        nh = curr_h + dh[i]
        nn = curr_n + dn[i]
        nm = curr_m + dm[i]
        
        # 범위 내에 있고, 익지 않은 토마토(0)라면
        if 0 <= nh < h and 0 <= nn < n and 0 <= nm < m:
            if graph[nh][nn][nm] == 0:
                # 익음 처리하고 이전 값 + 1 (날짜 카운트)
                graph[nh][nn][nm] = graph[curr_h][curr_n][curr_m] + 1
                queue.append((nh, nn, nm))

# 5. 결과 확인
max_days = 0
for i in range(h):
    for j in range(n):
        for k in range(m):
            # 토마토가 다 익지 못한 경우
            if graph[i][j][k] == 0:
                print(-1)
                exit()
            # 가장 오래 걸린 날짜 찾기
            max_days = max(max_days, graph[i][j][k])

# 처음 시작이 1이었으므로 1을 빼줘야 실제 경과 일수가 나옴
if max_days == 1:
    print(0) # 처음부터 다 익어있었던 경우
else:
    print(max_days - 1)
```

## 🔍 핵심 포인트

1. **3차원 좌표**: (높이, 세로, 가로) 순서로 관리
2. **6방향 이동**: 2차원의 4방향에서 위/아래 2방향이 추가됨
3. **다중 시작점**: 처음부터 익어있는 모든 토마토를 큐에 담고 시작
4. **날짜 계산**: 시작이 1이므로 최종 결과에서 1을 빼줘야 함

## 📊 시간 복잡도

- **시간복잡도**: O(H × N × M)
  - 모든 칸을 최대 한 번씩 방문
- **공간복잡도**: O(H × N × M)
  - 3차원 그래프 저장 및 큐 사용

## 🔧 트러블 슈팅 & 어려웠던 점

### 1. 3차원 좌표 관리의 혼란

처음에는 (x, y, z) 좌표를 어떤 순서로 관리해야 할지 혼란스러웠습니다. 입력 순서가 `M(가로), N(세로), H(높이)` 순으로 주어지지만, 실제 그래프를 구성할 때는 높이를 바깥 반복문으로 두는 것이 직관적이었습니다.

**해결**: `graph[높이][세로][가로]` 형태로 일관되게 관리하고, 방향 배열도 `dh, dn, dm` 순서로 맞춰서 혼동을 줄였습니다.

### 2. 6방향 탐색 설정 실수

2차원에서는 상하좌우 4방향만 고려하면 되지만, 3차원에서는 위/아래 방향까지 추가해야 합니다. 처음에 방향 배열을 잘못 설정하여 일부 케이스에서 오답이 발생했습니다.

**해결**: 
```python
dh = [1, -1, 0, 0, 0, 0]  # 위, 아래
dn = [0, 0, 1, -1, 0, 0]  # 앞, 뒤
dm = [0, 0, 0, 0, 1, -1]  # 좌, 우
```
명확하게 주석을 달아 각 방향을 명시했습니다.

### 3. 범위 체크의 중요성

3차원이다 보니 범위 체크 조건이 더 복잡해졌습니다. `h, n, m` 세 가지 모두를 체크해야 하는데, 하나라도 누락하면 인덱스 에러가 발생합니다.

**해결**: 조건문을 명확하게 작성하고, 각 차원별로 범위를 확인했습니다.
```python
if 0 <= nh < h and 0 <= nn < n and 0 <= nm < m:
```

### 4. 처음부터 모든 토마토가 익어있는 경우

`max_days`가 1인 경우는 모든 토마토가 처음부터 익어있던 상황입니다. 이 예외 케이스를 처리하지 않으면 0이 아닌 0을 출력하게 됩니다.

**해결**: 최종 출력 전에 `max_days == 1`인 경우를 별도로 처리하여 0을 출력하도록 했습니다.

## 🤔 후기

2차원 토마토 문제의 확장 버전입니다. 차원만 늘어났을 뿐 BFS의 기본 로직은 동일하기 때문에, 2차원 BFS를 이해하고 있다면 어렵지 않게 풀 수 있는 문제였습니다.
