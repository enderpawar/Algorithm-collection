# 알고리즘 문제 해결: 좌표 압축과 분할 정복

> 효율적인 자료구조 활용과 재귀적 문제 해결 전략

## 🎯 백준 18870번: 좌표 압축 (Coordinate Compression)

### Problem Overview
**문제 분류**: 정렬, 해시맵  
**난이도**: Silver II  
**핵심 키워드**: 좌표 압축, 해시맵, 정렬

수직선 위의 N개 좌표(최대 1,000,000개)를 압축하는 문제입니다. 좌표 압축은 각 좌표 값을 "자신보다 작은 서로 다른 좌표의 개수"로 치환하여, 값의 범위를 줄이면서도 상대적 순서는 유지하는 기법입니다.

### Problem Solving Strategy

#### 1. 문제 분석
좌표 압축이 필요한 실제 사례:
- **메모리 최적화**: 좌표 범위가 -10억 ~ +10억이지만 개수는 적을 때
- **Implementation

```python
import sys

def coordinate_compression(x_list):
    """
    좌표 압축을 수행하는 함수
    
    Args:
        x_list: 압축할 좌표 리스트
    
    Returns:
        압축된 좌표 리스트
    """
    # Step 1: 중복 제거 및 정렬 - O(M log M)
    sorted_unique = sorted(set(x_list))
    
    # Step 2: 해시맵 생성 (값 → 압축된 인덱스) - O(M)
    compress_map = {val: idx for idx, val in enumerate(sorted_unique)}
    
    # Step 3: 원본 순서대로 압축된 값 반환 - O(N)
    return [compress_map[x] for x in x_list]

# 입력 처리
n = int(sys.stdin.readline().strip())
x_list = list(map(int, sys.stdin.readline().split()))

# 좌표 압축 수행 및 출력
result = coordinate_compression(x_list)
print(' '.join(map(str, result)))
```

### Complexity Analysis

| 연산 | 시간 복잡도 | 설명 |
|------|------------|------|
| 중복 제거 (Set) | O(N) | 해시 기반 중복 제거 |
| 정렬 (Sort) | O(M log M) | M = 중복 제거 후 개수 |
| 해시맵 생성 | O(M) | 딕셔너리 컴프리헨션 |
| 결과 매핑 | O(N) | 해시맵 조회 O(1) × N |
| **총합** | **O(N + M log M)** | M ≤ N |

**공간 복잡도**: O(M) - 정렬된 리스트와 해시맵

### Key Takeaways

1. **자료구조 선택의 중요성**
   - 단순 리스트 탐색(O(N²)) vs 해시맵 활용(O(N))
   - 적절한 자료구조가 알고리즘 효율을 결정

2. **좌표 압축의 실전 활용**
   - 세그먼트 트리의 좌표 압축
   - 이산화(Discretization)를 통한 메모리 절약
   - 순위 기반 알고리즘의 전처리

3. **Python의 효율적인 패턴**
   - Dictionary comprehension의 간결함
   - `enumerate()`를 통한 인덱스-값 동시 처리
   - Set을 활용한 O(N) 중복 제거
# 2. X 좌표들 입력 (리스트 형태)
x_list = list(map(int, sys.stdin.readline().split()))

# 좌표 압축 방법 1. 중복 제거 set 2. 정렬 sort 3. 순위 매기기 dictionary 
🎯 백준 2630번: 색종이 만들기 (Divide and Conquer)

### Problem Overview
**문제 분류**: 분할 정복, 재귀  
**난이도**: Silver II  
**핵심 키워드**: Divide and Conquer, Quadtree, 재귀

N×N 크기의 색종이(각 칸은 0 또는 1)를 같은 색으로만 이루어진 정사각형들로 최소 분할할 때, 각 색상의 정사각형 개수를 구하는 문제입니다.

### Problem Solving Strategy

#### 1. 문제 분석과 패턴 인식

이 문제는 **쿼드트리(Quadtree)** 자료구조의 구현 원리와 동일합니다.

**쿼드트리의 실제 활용**:
- 이미지 압축 (JPEG, PNG 등)
- 공간 분할 (게임 충돌 감지, 지도 렌더링)
- 지리 정보 시스템 (GIS)

#### 2. 분할 정복 설계
Implementation

```python
import sys

class PaperCounter:
    """색종이를 분할 정복으로 카운팅하는 클래스"""
    
    def __init__(self, paper):
        self.paper = paper
        self.white_count = 0
        self.blue_count = 0
    
    def is_uniform(self, x, y, size):
        """
        주어진 영역이 단일 색상인지 확인
        
        Args:
            x, y: 시작 좌표
            size: 영역 크기
        
        Returns:
            (bool, int): (단일 색상 여부, 색상 값)
        """
        base_color = self.paper[x][y]
        
        for i in range(x, x + size):
            for j in range(y, y + size):
                if self.paper[i][j] != base_color:
                    return False, -1
        
        return True, base_color
    
    def divide_and_conquer(self, x, y, size):
        """
        분할 정복으로 색종이 카운팅
        
        Time Complexity: O(N²)
        - 각 셀을 최대 한 번 방문
        - 재귀 깊이: O(log N)
        """
        # Base Case: 영역이 단일 색상인가?
        uniform, color = self.is_uniform(x, y, size)
        
        if uniform:
            if color == 0:
                self.white_count += 1
            else:
                self.blue_count += 1
            return
        
        # Recursive Case: 4등분하여 재귀 호출
        half = size // 2
        self.divide_and_conquer(x, y, half)                    # Q1: 좌상
        self.divide_and_conquer(x, y + half, half)             # Q2: 우상
        self.divide_and_conquer(x + half, y, half)             # Q3: 좌하
        self.divide_and_conquer(x + half, y + half, half)      # Q4: 우하
    
    def solve(self):
        """문제 해결 실행"""
        self.divide_and_conquer(0, 0, len(self.paper))
        return self.white_count, self.blue_count

# 입력 처리
n = int(sys.stdin.readline().strip())
paper = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]

# 문제 해결
counter = PaperCounter(paper)
white, blue = counter.solve()

print(white)
print(blue)
```

### Complexity Analysis

**시간 복잡도**: O(N²)
- 각 셀은 재귀 호출 스택에서 최대 log N번 검사됨
- 하지만 각 레벨에서 전체 셀의 합은 N²을 초과하지 않음
- 마스터 정리: T(n) = 4T(n/2) + O(n²) = O(n²)

**공간 복잡도**: O(log N)
- 재귀 호출 스택의 깊이
- 완전 4진 트리의 높이 = log₄(N²) = log N

**최악� 문제 해결 종합 분석

### 공통 패턴과 차이점

| 특성 | 좌표 압축 | 색종이 만들기 |
|------|----------|-------------|
| 패러다임 | 정렬 + 해싱 | 분할 정복 |
| 시간 복잡도 | O(N log N) | O(N²) |
| 공간 복잡도 | O(N) | O(log N) |
| 핵심 자료구조 | HashMap | Recursion Stack |
| 최적화 포인트 | 해시 조회 | 조기 종료 |

### 알고리즘 설계 원칙

1. **적절한 자료구조 선택**
   - 빈번한 조회 → HashMap (O(1))
   - 순서 유지 필요 → 정렬 + 인덱싱
   - 계층적 구조 → 재귀 / 트리

2. **시간-공간 트레이드오프**
   - 좌표 압축: 추가 공간(해시맵) 사용으로 시간 절약
   - 색종이: 재귀 스택 공간으로 코드 간결성 확보

3. **조기 최적화의 중요성**
   - 불필요한 연산 제거 (조기 return)
   - 캐싱을 통한 중복 계산 방지

### 실무 연결고리

**좌표 압축 기법의 확장**:
- **데이터베이스 인덱싱**: 희소 데이터의 효율적 저장
- **추천 시스템**: 사용자/아이템 ID의 연속적 매핑
- **시계열 데이터**: 타임스탬프 정규화

**분할 정복의 실전 활용**:
- **병렬 처리**: 독립적인 부분 문제를 병렬 실행
- **최적화 문제**: 탐색 공간 효율적 분할
- **시스템 설계**: Microservice 아키텍처

## 🎓 학습 정리 및 다음 단계

### 이번 학습의 핵심 가치

1. **문제 해결 프로세스**
   - 문제 분석 → 패턴 인식 → 알고리즘 선택 → 최적화

2. **코드 품질 향상**
   - 명확한 함수 분리
   - 의미 있는 변수명
   - 시간/공간 복잡도 분석

3. **실무 관점의 사고**
   - 단순 구현을 넘어 확장성 고려
   - 실제 활용 사례와 연결
   - 트레이드오프 이해

### Next Steps

- [ ] **관련 문제 확장**: 세그먼트 트리, 머지소트 트리
- [ ] **최적화 실습**: 메모이제이션, DP 패턴
- [ ] **실전 적용**: 프로젝트에 좌표 압축/쿼드트리 활용

---

*본 글은 백준 온라인 저지의 문제를 기반으로 작성되었습니다.*  
*문제 출처: [백준 18870](https://www.acmicpc.net/problem/18870), [백준 2630](https://www.acmicpc.net/problem/2630)*
1 0 1 0
```

### Key Takeaways

1. **분할 정복 패턴 인식**
   - 문제를 동일한 구조의 부분 문제로 분할 가능한가?
   - 부분 문제의 해를 합쳐 전체 해를 구성할 수 있는가?
   - Base case가 명확한가?

2. **재귀 설계의 핵심 원칙**
   ```python
   def recursive_function():
       # 1. Base Case 처리
       if base_condition:
           return result
       
       # 2. Recursive Case 처리
       subproblems = divide()
       results = [recursive_function(sub) for sub in subproblems]
       
       # 3. 결과 통합
       return combine(results)
   ```

3. **실전 적용 가능성**
   - 이미지 처리: 쿼드트리 기반 압축
   - 공간 분할: 게임 엔진의 공간 파티셔닝
   - 병렬 처리: 각 사분면을 독립적으로 처리 가능
  - 3사분면 (왼쪽 아래)
  - 4사분면 (오른쪽 아래)

### 코드
```python
import sys

n = int(sys.stdin.readline().strip())
paper = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]

white = 0 
blue = 0

def div(x, y, n): # x, y: 시작 좌표 / n: 현재 크기
    global white, blue
    
    # 1. 기준 색상 정하기 (현재 사각형의 맨 왼쪽 위 칸)
    base_color = paper[x][y]
    
    # 2. 현재 영역(x~x+n, y~y+n)을 탐색
    for i in range(x, x + n):
        for j in range(y, y + n):
            # 기준 색상과 다른 게 하나라도 나오면
            if paper[i][j] != base_color:
                # 3. 4등분해서 다시 던지기
                half = n // 2
                div(x, y, half)               # 1사분면 (왼위)
                div(x, y + half, half)        # 2사분면 (오위)
                div(x + half, y, half)        # 3사분면 (왼아래)
                div(x + half, y + half, half) # 4사분면 (오아래)
                return # 중요! 쪼개서 들어갔다 왔으면 현재 함수는 종료해야 함
    
    # 4. 반복문을 무사히 마쳤다면 (모든 칸이 같은 색)
    if base_color == 0:
        white += 1
    else:
        blue += 1

# 처음에 전체 크기로 시작!
div(0, 0, n)

print(white)
print(blue)
```

### 시간 복잡도
- 각 칸을 최대 한 번씩만 방문하므로 **O(N²)**
- 재귀 깊이는 최대 log N

### 주의할 점
1. **return 문의 중요성**: 4등분하여 재귀 호출한 후 반드시 `return`해야 합니다. 그렇지 않으면 4등분한 영역에 대해서도 카운트가 증가하여 중복 카운팅됩니다.

2. **좌표 계산**: 
   - `div(x, y + half, half)`: y좌표를 반만큼 이동 (오른쪽으로)
   - `div(x + half, y, half)`: x좌표를 반만큼 이동 (아래로)

### 배운 점
- 분할 정복 문제의 기본 패턴을 익힐 수 있었습니다
- 재귀 함수에서 조건에 따른 `return`의 중요성을 다시 한번 깨달았습니다
- 전역 변수를 사용하여 카운트를 관리하는 방법도 유용합니다

---

## 💡 오늘의 회고
- **좌표 압축**: 정렬과 딕셔너리를 활용한 효율적인 매핑 기법
- **분할 정복**: 재귀의 기본 원리와 영역 분할 방법 학습

두 문제 모두 알고리즘의 기본 개념을 다지는 데 도움이 되는 좋은 문제였습니다! 🚀
