# 2026년 1월 11일 알고리즘 풀이 정리

## 📌 목차
1. [백준 1389 - 케빈 베이컨의 6단계 법칙](#1-백준-1389---케빈-베이컨의-6단계-법칙)
2. [과일 탕후루 (투 포인터)](#2-과일-탕후루-투-포인터)

---

## 1. 백준 1389 - 케빈 베이컨의 6단계 법칙

### 🔗 문제 링크
[백준 1389번](https://www.acmicpc.net/problem/1389)

### 📝 문제 설명
N명의 사람들이 주어지고, 친구 관계가 주어질 때 케빈 베이컨의 수가 가장 작은 사람을 구하는 문제입니다. 케빈 베이컨의 수는 자신을 제외한 모든 사람과의 최단 거리의 합입니다.

### 💡 핵심 알고리즘
- **BFS (너비 우선 탐색)**
- **그래프 탐색**
- **최단 거리 계산**

### 🎯 접근 방법

1. **그래프 구성**: 양방향 인접 리스트로 친구 관계를 표현
2. **BFS를 통한 최단 거리 계산**: 각 사람을 시작점으로 BFS를 실행하여 다른 모든 사람까지의 최단 거리를 구함
3. **케빈 베이컨 수 계산**: 각 사람에 대해 모든 거리의 합을 구함
4. **최솟값 찾기**: 가장 작은 케빈 베이컨 수를 가진 사람의 번호를 출력

### 💻 구현 코드

```python
import sys
from collections import deque

input = sys.stdin.readline

# 1. N(사람 수), M(관계 수) 입력
n, m = map(int, input().split())

# 2. 인접 리스트 만들기 (1번~N번까지 사용하기 위해 n+1)
adj = [[] for _ in range(n+1)]

# 3. M개의 친구 관계 입력받아 저장하기
for _ in range(m):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u) # 친구는 양방향!

# 4. 각 사람의 점수를 담을 리스트 (인덱스 맞추기 위해 n+1)
bacon_counts = [0] * (n+1)

def bfs(a):
    # 1. 거리 기록지 (visited 역할 겸 거리 저장)
    dist = [-1] * (n+1)
    dist[a] = 0 

    queue = deque([a])              

    while queue:
        curr = queue.popleft()

        for neighbor in adj[curr]:
            if dist[neighbor] == -1:
                dist[neighbor] = dist[curr] + 1
                queue.append(neighbor)

    return sum(dist) + 1 # 각 정점의 베이컨 값들 정리 

for i in range(1,n+1):
    bacon_counts[i] = bfs(i)

bacon_counts[0] = 999999999 #0에 가장 큰 값 넣기

min_score = min(bacon_counts)
print(bacon_counts.index(min_score))
```

### ⚠️ 마주한 문제 및 주의사항

1. **인덱스 처리**: 사람 번호가 1번부터 시작하므로 리스트 크기를 `n+1`로 설정
2. **거리 합 계산 시 주의**: `sum(dist) + 1`에서 dist에는 -1 값들이 포함되어 있을 수 있음. 실제로는 방문한 노드들의 거리만 합산해야 하므로 `sum(d for d in dist if d != -1)`로 수정하는 것이 더 정확함
3. **0번 인덱스 처리**: 0번은 사용하지 않으므로 큰 값을 넣어 최솟값 검색에서 제외

### 📊 시간 복잡도
- **시간 복잡도**: O(N × (N + M))
  - 각 사람마다 BFS 수행: O(N)
  - 각 BFS는 O(N + M)
- **공간 복잡도**: O(N + M)

### 💭 배운 점
- BFS를 활용하여 무방향 그래프에서 최단 거리를 구하는 전형적인 문제
- 모든 노드에서 다른 노드까지의 최단 거리를 구할 때는 각 노드마다 BFS를 실행하는 방법 사용
- 1-indexed 배열을 다룰 때 0번 인덱스 처리에 주의해야 함

---

## 2. 과일 탕후루 (투 포인터)

### 📝 문제 설명
N개의 과일이 일렬로 놓여있을 때, 연속된 구간에서 **최대 2종류의 과일**만을 선택하여 만들 수 있는 **가장 긴 구간의 길이**를 구하는 문제입니다.

### 💡 핵심 알고리즘
- **투 포인터 (Two Pointers)**
- **슬라이딩 윈도우 (Sliding Window)**
- **해시맵 (Dictionary)**

### 🎯 접근 방법

1. **투 포인터 설정**: `left`와 `right` 포인터로 구간을 관리
2. **오른쪽 확장**: `right`를 증가시키며 과일을 구간에 추가
3. **조건 체크**: 과일 종류가 2개를 초과하면 `left`를 이동하며 구간 축소
4. **딕셔너리 관리**: 현재 구간의 과일 종류별 개수를 저장하고, 개수가 0이 되면 해당 종류 삭제
5. **최댓값 갱신**: 매 순간 유효한 구간의 길이를 계산하여 최댓값 갱신

### 💻 구현 코드

```python
import sys
input = sys.stdin.readline

# 1. 입력 받기
n = int(input())
fruits = list(map(int, input().split()))

# 2. 돋보기(구간) 설정
left = 0
max_len = 0
count = {} # 과일 종류별 개수를 담을 주머니

for right in range(n):
    # 오른쪽 과일을 주머니에 넣기 (종류 카운트)
    f_right = fruits[right]
    count[f_right] = count.get(f_right, 0) + 1 #get(key, default) -> f_right가 count에 있으면 저장된 개수를, 없으면 0 을 가져오기 
    
    # 종류 수가 2개를 �넘으면 왼쪽을 뺀다!
    while len(count) > 2:
        f_left = fruits[left]
        count[f_left] -= 1
        
        # 개수가 0이 되면 주머니에서 완전히 비워야 '종류 수'가 줄어듦
        if count[f_left] == 0:
            del count[f_left]
        
        left += 1 # 왼쪽 포인터 이동
        
    # 현재 두 종류 이하인 구간의 길이를 재서 최댓값 비교
    max_len = max(max_len, right - left + 1)

print(max_len)
```

### ⚠️ 마주한 문제 및 주의사항

1. **딕셔너리에서 키 삭제 시점**: 단순히 개수를 0으로 만드는 것이 아니라 `del`로 키 자체를 삭제해야 `len(count)`가 정확하게 종류 수를 반영함
2. **get() 메서드 활용**: `count.get(f_right, 0)`을 사용하여 KeyError 방지
3. **while vs if**: 종류 수가 2개를 초과할 때 `if`가 아닌 `while`을 사용해야 여러 단계 축소 가능

### 📊 시간 복잡도
- **시간 복잡도**: O(N)
  - `right` 포인터가 N번 이동
  - `left` 포인터도 최대 N번 이동
  - 각 원소는 최대 2번(추가 1번, 제거 1번) 처리됨
- **공간 복잡도**: O(K), K는 과일의 종류 수 (최대 2개 유지)

### 💭 배운 점
- 투 포인터 기법은 연속된 구간에서 조건을 만족하는 최대/최소 길이를 구할 때 효과적
- 슬라이딩 윈도우에서 해시맵을 활용하여 구간의 상태를 효율적으로 관리
- `get()` 메서드와 `del` 키워드를 활용한 딕셔너리 관리 기법
- 구간의 확장(right)과 축소(left)를 분리하여 생각하면 구현이 명확해짐

---

## 🎓 오늘의 총평

오늘은 **그래프 탐색(BFS)**과 **투 포인터** 두 가지 중요한 알고리즘을 복습했습니다. 

- **BFS**: 최단 거리 계산에 활용, 모든 노드에서 시작하는 탐색 연습
- **투 포인터**: 연속 구간 문제에서 효율적인 해결 방법, 딕셔너리를 활용한 상태 관리

두 문제 모두 자주 출제되는 유형이므로 구현 패턴을 확실히 익혀두는 것이 중요합니다! 💪
