# 알고리즘 문제풀이 정리 (2026.01.08)

## 📚 오늘 푼 문제
1. **백준 1697번 - 숨바꼭질** (BFS)
2. **백준 2667번 - 단지번호붙이기** (DFS)

---

## 1️⃣ 백준 1697번 - 숨바꼭질

### 🎯 문제 분석
- **문제 유형**: 최단거리 탐색 (BFS)
- **목표**: 수빈이가 동생을 찾는 가장 빠른 시간 구하기
- **이동 방법**: 
  - X-1 (한 칸 뒤로)
  - X+1 (한 칸 앞으로)
  - X*2 (순간이동)

### 💡 접근 방법
1. **BFS 선택 이유**: 최단 시간을 구해야 하므로 BFS가 적합
2. **방문 배열 활용**: `visited[i]`에 해당 위치까지 가는데 걸린 시간 저장
3. **범위 제한**: 0 ≤ 위치 ≤ 100,000

### 📝 핵심 코드
```python
from collections import deque

n, k = map(int, input().split())
queue = deque([n])
visited = [-1] * 100001
visited[n] = 0

def bfs(a):
    while queue:
        curr = queue.popleft()
        
        if curr == k:
            print(visited[curr])
            break
        
        # 세 가지 이동 방법
        for next_pos in (curr-1, curr+1, curr*2):
            # 범위 체크 & 미방문 체크
            if 0 <= next_pos <= 100000 and visited[next_pos] == -1:
                visited[next_pos] = visited[curr] + 1
                queue.append(next_pos)

bfs(n)
```

### 🔑 알아둬야 할 개념

#### 1. **BFS (너비 우선 탐색)**
- 가까운 노드부터 탐색하는 알고리즘
- **최단 거리** 문제에 적합
- `deque`를 사용하여 효율적인 구현
- 시간복잡도: O(V + E)

#### 2. **visited 배열의 활용**
```python
visited = [-1] * 100001  # -1: 미방문, 0 이상: 방문 + 시간 저장
```
- 방문 여부 체크와 동시에 거리(시간) 저장
- 메모리 최적화

#### 3. **범위 제한의 중요성**
```python
if 0 <= next_pos <= 100000 and visited[next_pos] == -1:
```
- **반드시 범위 체크 먼저!**
- IndexError 방지
- 불필요한 탐색 제거

### ⚠️ 주의할 점
- 범위를 벗어나는 경우 반드시 체크
- BFS는 Queue(deque) 사용, DFS는 Stack 또는 재귀 사용
- 방문 체크를 안하면 무한루프 발생 가능

---

## 2️⃣ 백준 2667번 - 단지번호붙이기

### 🎯 문제 분석
- **문제 유형**: 그래프 탐색, 연결 요소 찾기 (DFS/BFS)
- **목표**: 
  1. 전체 단지 수 구하기
  2. 각 단지의 집 개수 구하기
- **조건**: 상하좌우로 연결된 집들이 하나의 단지

### 💡 접근 방법
1. **DFS 선택 이유**: 연결된 모든 요소를 찾는 문제에 DFS/BFS 모두 가능
2. **2차원 배열 탐색**: 모든 좌표를 확인하며 집(1)이면서 미방문인 곳 탐색
3. **방향 벡터 활용**: 상하좌우 이동을 배열로 관리

### 📝 핵심 코드
```python
N = int(input())
visited = [[0] * N for _ in range(N)]
graph = [list(map(int, input())) for _ in range(N)]

dx = [-1, 1, 0, 0]   # 상, 하
dy = [0, 0, -1, 1]   # 좌, 우

group = 0      # 단지 수
home = []      # 각 단지의 집 개수

def dfs(a, b):
    visited[a][b] = 1
    home[group-1] += 1  # 현재 단지의 집 개수 증가
    
    # 상하좌우 탐색
    for i in range(4):
        na = a + dx[i]
        nb = b + dy[i]
        
        # 범위 체크 & 집인지 & 미방문 체크
        if 0 <= na < N and 0 <= nb < N:
            if graph[na][nb] == 1 and not visited[na][nb]:
                dfs(na, nb)

# 전체 그래프 탐색
for a in range(N):
    for b in range(N):
        if graph[a][b] == 1 and not visited[a][b]:
            group += 1
            home.append(0)
            dfs(a, b)

print(group)
home.sort()
for h in home:
    print(h)
```

### 🔑 알아둬야 할 개념

#### 1. **DFS (깊이 우선 탐색)**
- 한 방향으로 끝까지 탐색 후 돌아오는 알고리즘
- **연결 요소** 찾기에 적합
- 재귀 또는 스택으로 구현
- 시간복잡도: O(V + E)

#### 2. **방향 벡터 (Direction Vector)**
```python
dx = [-1, 1, 0, 0]   # 상, 하, 좌, 우
dy = [0, 0, -1, 1]
```
- 상하좌우 이동을 간결하게 표현
- 대각선 포함 시: 8방향
```python
dx = [-1, -1, -1, 0, 0, 1, 1, 1]
dy = [-1, 0, 1, -1, 1, -1, 0, 1]
```

#### 3. **2차원 배열 입력 처리**
```python
# '01101' 문자열을 [0, 1, 1, 0, 1] 리스트로 변환
graph = [list(map(int, input())) for _ in range(N)]
```

#### 4. **visited 배열 (2차원)**
```python
visited = [[0] * N for _ in range(N)]
# 또는
visited = [[False] * N for _ in range(N)]
```

### ⚠️ 주의할 점
1. **범위 체크 먼저!**
   ```python
   if 0 <= na < N and 0 <= nb < N:  # 이 조건을 항상 먼저 확인
       if graph[na][nb] == 1 and not visited[na][nb]:
   ```

2. **비교 연산자 실수 방지**
   ```python
   if graph[a][b] == 1:  # ✅ 비교 연산자
   if graph[a][b] = 1:   # ❌ 할당 연산자 (SyntaxError)
   ```

3. **재귀 깊이 제한**
   - Python의 기본 재귀 깊이: 1000
   - 필요시 증가:
   ```python
   import sys
   sys.setrecursionlimit(10000)
   ```

---

## 📊 DFS vs BFS 비교

| 구분 | DFS | BFS |
|------|-----|-----|
| **자료구조** | Stack (재귀) | Queue (deque) |
| **탐색 방식** | 깊이 우선 | 너비 우선 |
| **적합한 문제** | 연결 요소, 경로 존재 여부 | 최단 거리, 최소 이동 |
| **메모리** | 상대적으로 적음 | 상대적으로 많음 |
| **구현** | 재귀로 간단 | deque 필요 |

### 선택 기준
- **최단 거리/최소 비용**: BFS 선택 ✅
- **모든 경로 탐색/연결 요소**: DFS 또는 BFS ✅
- **경로 존재 여부**: DFS가 조금 더 효율적 ✅

---

## 🎓 핵심 정리

### 공통 개념
1. **방문 체크의 중요성**: 무한 루프 방지
2. **범위 체크**: IndexError 방지, 항상 먼저 체크!
3. **문제 유형 파악**: 최단거리 → BFS, 연결요소 → DFS/BFS

### Python 팁
```python
# deque 임포트
from collections import deque

# 2차원 배열 초기화
arr = [[0] * cols for _ in range(rows)]

# 입력을 한 줄에 리스트로
arr = [list(map(int, input())) for _ in range(n)]

# 방향 벡터 (상하좌우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
```

### 디버깅 체크리스트
- [ ] 범위 체크를 했는가?
- [ ] 방문 체크를 했는가?
- [ ] 비교 연산자(`==`)를 제대로 사용했는가?
- [ ] 입력 형식이 올바른가?
- [ ] 재귀 깊이 제한은 괜찮은가?

---

## 💪 다음 학습 계획
- [ ] BFS/DFS 관련 문제 더 풀어보기
- [ ] 최단 경로 알고리즘 (다익스트라, 벨만-포드)
- [ ] 위상 정렬
- [ ] Union-Find (Disjoint Set)

---

> 📌 **오늘의 교훈**  
> "범위 체크를 먼저, 비교 연산자 확실히!"  
> 작은 실수들이 쌓이면 큰 시간 낭비가 됩니다. 꼼꼼히 체크하는 습관을 들이자! 💯
